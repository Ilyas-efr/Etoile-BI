<!doctype html>
<html lang="fr">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>Étoile BI — Dessins géométriques</title>
        <link rel="stylesheet" href="style.css" />
        <style>
            body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 12px; background: #fff; }
            .controls { margin-bottom: 12px; }
            .controls button { margin-right: 8px; padding: 6px 10px; }
            #sketch-container { display:block; }
        </style>
    </head>
    <body>
        <div class="controls">
            <button id="btn-png">Télécharger PNG</button>
            <button id="btn-svg">Télécharger SVG</button>
            <span style="margin-left:12px;color:#666;font-size:0.9rem">Librairie v3ga incluse (init_trace.js)</span>
        </div>

        <div id="sketch-container">
            <!-- Le canevas p5 ou l'élément SVG sera ajouté ici par la librairie -->
        </div>

        <!-- p5.js (CDN) -->
        <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
        <!-- v3ga library (init_trace.js) -->
        <script src="https://www.v3ga.net/dessins_geometriques/init_trace.js"></script>
        <!-- sketch (local) -->
        <script src="sketch.js"></script>

        <script>
            // Remplace appendChild(document.body...) usages in the v3ga lib by a container
            // If init_trace.js appends elements to document.body, we can move them inside #sketch-container
            const container = document.getElementById('sketch-container');

            // When the page has an SVG or canvas appended by the library, move it into container
            const observer = new MutationObserver((mutations) => {
                for (const m of mutations) {
                    for (const node of m.addedNodes) {
                        if (node.nodeType === 1) {
                            const tag = node.tagName.toLowerCase();
                            if (tag === 'svg' || tag === 'canvas') {
                                // Move into container
                                container.appendChild(node);
                            }
                        }
                    }
                }
            });
            observer.observe(document.body, { childList: true });

            document.getElementById('btn-png').addEventListener('click', () => {
                // If the library created an SVG and _SVG_ is true, create a raster PNG from it
                const svgEl = container.querySelector('svg');
                if (svgEl) {
                    // serialize and draw to canvas
                    const svgData = new XMLSerializer().serializeToString(svgEl);
                    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(svgBlob);
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = svgEl.viewBox.baseVal.width || svgEl.clientWidth || 500;
                        canvas.height = svgEl.viewBox.baseVal.height || svgEl.clientHeight || 500;
                        const ctx = canvas.getContext('2d');
                        // white background
                        ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);
                        ctx.drawImage(img, 0, 0);
                        URL.revokeObjectURL(url);
                        canvas.toBlob((blob) => {
                            const a = document.createElement('a');
                            a.href = URL.createObjectURL(blob);
                            a.download = 'dessin.png';
                            document.body.appendChild(a);
                            a.click();
                            a.remove();
                        }, 'image/png');
                    };
                    img.onerror = () => { URL.revokeObjectURL(url); alert('Erreur lors de la conversion SVG→PNG'); };
                    img.src = url;
                } else if (typeof save_ === 'function') {
                    // try using the library save_ which will call save() for canvas
                    try { save_('dessin.png'); } catch (e) { alert('Impossible d\'enregistrer en PNG : ' + e); }
                } else {
                    alert('Aucun dessin détecté pour l\'export PNG.');
                }
            });

            document.getElementById('btn-svg').addEventListener('click', () => {
                // If an SVG element already exists, download it. Otherwise, re-render in SVG mode.
                const svgEl = container.querySelector('svg');
                if (svgEl) {
                    const data = '<?xml version="1.0" standalone="no"?>\n' + new XMLSerializer().serializeToString(svgEl);
                    const blob = new Blob([data], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url; a.download = 'dessin.svg'; document.body.appendChild(a); a.click(); a.remove();
                    URL.revokeObjectURL(url);
                } else {
                    // Ask the sketch to render SVG by calling a global helper if available
                    if (typeof renderDessin === 'function') {
                        // Remove existing canvas if present
                        const c = container.querySelector('canvas'); if (c) c.remove();
                        // Call renderDessin with svg:true and then trigger save_
                        try {
                            renderDessin({ svg: true });
                            // small timeout to allow svg to be created
                            setTimeout(() => { try { save_('dessin.svg'); } catch (e) { alert('Erreur export SVG: ' + e); } }, 250);
                        } catch (e) { alert('Impossible de rendre le dessin en SVG : ' + e); }
                    } else {
                        alert('L\'export SVG nécessite que le sketch supporte renderDessin({svg:true}).');
                    }
                }
            });
        </script>
    </body>
</html>